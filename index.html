<!-- LÃ“GICA DA APLICAÃ‡ÃƒO -->
<script type="module">
    // 1. IMPORTAÃ‡Ã•ES CORRETAS (Via URL para funcionar no navegador)
    import { initializeApp } from "https://www.gstatic.com/firebasejs/9.22.0/firebase-app.js";
    import { getAuth, createUserWithEmailAndPassword, signInWithEmailAndPassword, onAuthStateChanged, signOut, updateProfile, sendPasswordResetEmail } from "https://www.gstatic.com/firebasejs/9.22.0/firebase-auth.js";
    import { getFirestore, collection, addDoc, getDocs, updateDoc, deleteDoc, doc, query, where, setDoc, orderBy, onSnapshot, Timestamp } from "https://www.gstatic.com/firebasejs/9.22.0/firebase-firestore.js";
    import { getStorage, ref, uploadBytes, getDownloadURL, deleteObject } from "https://www.gstatic.com/firebasejs/9.22.0/firebase-storage.js";
    // Biblioteca externa para exportar Excel (necessÃ¡ria para a funÃ§Ã£o exportToCSV)
    import * as XLSX from "https://cdn.sheetjs.com/xlsx-0.20.0/package/xlsx.mjs";

    // 2. CONFIGURAÃ‡ÃƒO LIMPA
    const firebaseConfig = {
      apiKey: "AIzaSyC5lYxqNHxCOBPH-ZFK9Br4PHnOCFzUyXs",
      authDomain: "prontuario-ee1fd.firebaseapp.com",
      projectId: "prontuario-ee1fd",
      storageBucket: "prontuario-ee1fd.firebasestorage.app",
      messagingSenderId: "107787636728",
      appId: "1:107787636728:web:480a29a155ce46f050100d",
      measurementId: "G-SSS053XG8W"
    };

    // 3. INICIALIZAÃ‡ÃƒO SEGURA
    let auth, db, storage;
    try {
        const app = initializeApp(firebaseConfig);
        auth = getAuth(app);
        db = getFirestore(app);
        storage = getStorage(app);
        console.log("Firebase conectado com sucesso!");
    } catch (e) {
        console.error("Erro ao conectar no Firebase:", e);
        alert("Erro de configuraÃ§Ã£o do Firebase. Verifique o console.");
    }

    // 4. APLICAÃ‡ÃƒO VUE
    const { createApp, reactive, ref: vueRef, computed, onMounted, watch } = Vue;

    createApp({
        setup() {
            // --- ESTADO GLOBAL ---
            const loading = vueRef(true);
            const currentUser = vueRef(null);
            const userData = vueRef(null);
            const authMode = vueRef('login');
            const sidebarOpen = vueRef(true);
            const isDark = vueRef(false);
            const currentView = vueRef('dashboard');
            const notifications = vueRef([]);
            
            // Dados
            const patients = vueRef([]);
            const appointments = vueRef([]);
            const users = vueRef([]);
            const records = vueRef([]);
            const files = vueRef([]);

            // FormulÃ¡rios e Modais
            const showModal = vueRef(null);
            const loginForm = reactive({ email: '', password: '' });
            const registerForm = reactive({ email: '', password: '', name: '' });
            const patientForm = reactive({ id: null, name: '', cpf: '', phone: '', email: '', anamnese: '' });
            const recordForm = reactive({ procedure: 'Limpeza', notes: '', cost: 0 });
            const appointmentForm = reactive({ patientId: '', date: '', hour: 9, procedure: '' });
            const searchQuery = vueRef('');
            const selectedPatient = vueRef(null);
            const selectedDate = vueRef(new Date().toISOString().split('T')[0]);

            // Constantes
            const workHours = [8, 9, 10, 11, 13, 14, 15, 16, 17, 18];
            const menuItems = [
                { id: 'dashboard', label: 'Painel', icon: 'fa-chart-pie', role: 'reception' },
                { id: 'patients', label: 'Pacientes', icon: 'fa-users', role: 'dentist' },
                { id: 'agenda', label: 'Agenda', icon: 'fa-calendar-alt', role: 'reception' },
                { id: 'users', label: 'UsuÃ¡rios', icon: 'fa-user-cog', role: 'admin' },
                { id: 'reports', label: 'RelatÃ³rios', icon: 'fa-file-invoice', role: 'admin' },
            ];

            // --- MÃ‰TODOS ---
            const notify = (message, type = 'info', title = 'Aviso') => {
                const id = Date.now();
                notifications.value.push({ id, message, type, title });
                setTimeout(() => {
                    notifications.value = notifications.value.filter(n => n.id !== id);
                }, 4000);
            };

            const toggleDarkMode = () => {
                isDark.value = !isDark.value;
                if (isDark.value) document.documentElement.classList.add('dark');
                else document.documentElement.classList.remove('dark');
            };

            const checkPermission = (requiredRole) => {
                if (!userData.value) return false;
                if(userData.value.role === 'admin') return true;
                if(requiredRole === 'reception') return true;
                if(requiredRole === 'dentist' && (userData.value.role === 'dentist')) return true;
                if(requiredRole === 'admin' && userData.value.role !== 'admin') return false;
                return true;
            };

            const syncData = () => {
                if(!db || !currentUser.value) return;

                onSnapshot(collection(db, 'patients'), (snap) => {
                    patients.value = snap.docs.map(d => ({ id: d.id, ...d.data() }));
                });
                onSnapshot(collection(db, 'appointments'), (snap) => {
                    appointments.value = snap.docs.map(d => ({ id: d.id, ...d.data() }));
                });
                onSnapshot(collection(db, 'records'), (snap) => {
                    records.value = snap.docs.map(d => ({ id: d.id, ...d.data() }));
                });
                onSnapshot(collection(db, 'files'), (snap) => {
                    files.value = snap.docs.map(d => ({ id: d.id, ...d.data() }));
                });
                
                if(userData.value?.role === 'admin') {
                    onSnapshot(collection(db, 'users'), (snap) => {
                        users.value = snap.docs.map(d => ({ uid: d.id, ...d.data() }));
                    });
                }
            };

            const handleLogin = async () => {
                try {
                    loading.value = true;
                    await signInWithEmailAndPassword(auth, loginForm.email, loginForm.password);
                    notify('Bem-vindo de volta!', 'success');
                } catch (e) {
                    notify('Erro ao entrar: ' + e.message, 'error');
                } finally { loading.value = false; }
            };

            const handleRegister = async () => {
                try {
                    loading.value = true;
                    const res = await createUserWithEmailAndPassword(auth, registerForm.email, registerForm.password);
                    await updateProfile(res.user, { displayName: registerForm.name });
                    
                    const usersSnap = await getDocs(collection(db, 'users'));
                    const role = usersSnap.empty ? 'admin' : 'reception';

                    await setDoc(doc(db, 'users', res.user.uid), {
                        name: registerForm.name,
                        email: registerForm.email,
                        role: role,
                        createdAt: new Date()
                    });
                    notify('Conta criada com sucesso!', 'success');
                } catch (e) {
                    notify('Erro no cadastro: ' + e.message, 'error');
                } finally { loading.value = false; }
            };

            const handleResetPassword = async () => {
                const email = prompt("Digite seu e-mail para recuperaÃ§Ã£o:");
                if(email) {
                    try {
                        await sendPasswordResetEmail(auth, email);
                        notify('Link de recuperaÃ§Ã£o enviado!', 'success');
                    } catch(e) { notify('Erro: ' + e.message, 'error'); }
                }
            };

            const logout = async () => {
                await signOut(auth);
                currentUser.value = null;
                userData.value = null;
                window.location.reload();
            };

            const savePatientForm = async () => {
                try {
                    const data = { 
                        name: patientForm.name, 
                        cpf: patientForm.cpf, 
                        phone: patientForm.phone, 
                        email: patientForm.email, 
                        anamnese: patientForm.anamnese 
                    };
                    if (patientForm.id) {
                        await updateDoc(doc(db, 'patients', patientForm.id), data);
                        notify('Paciente atualizado.', 'success');
                    } else {
                        await addDoc(collection(db, 'patients'), { ...data, createdAt: new Date().toISOString() });
                        notify('Paciente cadastrado.', 'success');
                    }
                    closeModal();
                } catch (e) { notify('Erro ao salvar paciente', 'error'); }
            };

            const editPatient = (p) => {
                Object.assign(patientForm, p);
                showModal.value = 'editPatient';
            };

            const selectPatient = (p) => {
                selectedPatient.value = p;
            };

            const checkConflicts = (date, hour) => {
                return appointments.value.some(a => a.date === date && parseInt(a.hour) === parseInt(hour) && a.status !== 'cancelado');
            };

            const saveAppointmentForm = async () => {
                if (checkConflicts(appointmentForm.date, appointmentForm.hour)) {
                    notify('HorÃ¡rio jÃ¡ ocupado!', 'error');
                    return;
                }
                try {
                    await addDoc(collection(db, 'appointments'), {
                        ...appointmentForm,
                        status: 'agendado',
                        dentistName: userData.value.name,
                        dentistId: userData.value.uid || currentUser.value.uid
                    });
                    notify('Agendamento realizado.', 'success');
                    closeModal();
                } catch (e) { notify('Erro ao agendar', 'error'); }
            };

            const getAppointmentsForHour = (hour) => {
                return appointments.value.filter(a => a.date === selectedDate.value && parseInt(a.hour) === hour && a.status !== 'cancelado');
            };

            const saveRecordForm = async () => {
                if (!selectedPatient.value) return;
                try {
                    await addDoc(collection(db, 'records'), {
                        patientId: selectedPatient.value.id,
                        dentistName: userData.value.name,
                        date: new Date().toISOString(),
                        procedure: recordForm.procedure,
                        notes: recordForm.notes,
                        cost: parseFloat(recordForm.cost)
                    });
                    notify('EvoluÃ§Ã£o registrada.', 'success');
                    closeModal();
                    recordForm.notes = ''; recordForm.cost = 0;
                } catch (e) { notify('Erro ao salvar evoluÃ§Ã£o', 'error'); }
            };

            const handleFileUpload = async (e) => {
                const file = e.target.files[0];
                if (!file) return;
                if (file.size > 5 * 1024 * 1024) return notify('Arquivo muito grande (Max 5MB)', 'error');

                try {
                    notify('Enviando arquivo...', 'info');
                    const storageRef = ref(storage, `uploads/${selectedPatient.value.id}/${Date.now()}_${file.name}`);
                    await uploadBytes(storageRef, file);
                    const url = await getDownloadURL(storageRef);

                    await addDoc(collection(db, 'files'), {
                        patientId: selectedPatient.value.id,
                        name: file.name,
                        url: url,
                        type: file.type,
                        uploadedAt: new Date().toISOString()
                    });
                    notify('Arquivo enviado!', 'success');
                } catch (err) { notify('Erro no upload', 'error'); }
            };

            const deleteFile = async (fileData) => {
                if(!confirm("Excluir arquivo permanentemente?")) return;
                try {
                    await deleteDoc(doc(db, 'files', fileData.id));
                    notify('Registro de arquivo removido.', 'success');
                } catch(e) { notify('Erro ao excluir', 'error'); }
            };

            const deleteUser = async (uid) => {
                if(confirm("Tem certeza?")) {
                    await deleteDoc(doc(db, 'users', uid));
                    notify('UsuÃ¡rio removido.', 'success');
                }
            };

            const exportToCSV = (type) => {
                try {
                    const data = type === 'patients' ? patients.value : appointments.value;
                    // Usa a biblioteca XLSX importada globalmente ou via CDN
                    if(typeof XLSX !== 'undefined') {
                        const ws = XLSX.utils.json_to_sheet(data);
                        const wb = XLSX.utils.book_new();
                        XLSX.utils.book_append_sheet(wb, ws, type);
                        XLSX.writeFile(wb, `odonto_export_${type}.xlsx`);
                        notify('Download iniciado.', 'success');
                    } else {
                        notify('Biblioteca XLSX nÃ£o carregada.', 'error');
                    }
                } catch(e) { console.error(e); }
            };

            const printRecord = () => {
                const element = document.getElementById('patient-record-content');
                html2pdf().from(element).save(`prontuario_${selectedPatient.value.name}.pdf`);
            };

            const backupData = () => {
                const backup = {
                    patients: patients.value,
                    appointments: appointments.value,
                    records: records.value,
                    date: new Date().toISOString()
                };
                const blob = new Blob([JSON.stringify(backup)], {type: "application/json"});
                const url = URL.createObjectURL(blob);
                const a = document.createElement('a');
                a.href = url; a.download = `backup_odonto_${Date.now()}.json`;
                a.click();
            };

            const restoreData = (e) => {
                const file = e.target.files[0];
                if(!file) return;
                const reader = new FileReader();
                reader.onload = async (evt) => {
                    try {
                        const data = JSON.parse(evt.target.result);
                        console.log("Dados para restore:", data);
                        notify('Check console for restore data.', 'info');
                    } catch(err) { notify('Arquivo invÃ¡lido', 'error'); }
                };
                reader.readAsText(file);
            };

            const runSelfTests = () => {
                console.group("ðŸ§ª Auto-Testes do Sistema");
                let passed = 0;
                let total = 0;
                total++;
                const testApts = [{date: '2023-01-01', hour: 10, status: 'agendado'}];
                const originalApts = appointments.value;
                appointments.value = testApts;
                const hasConflict = checkConflicts('2023-01-01', 10);
                if(hasConflict) { console.log("âœ… Teste Conflito: Passou"); passed++; }
                else console.error("âŒ Teste Conflito: Falhou");
                appointments.value = originalApts;

                total++;
                if(patientForm.cpf === '') { console.log("âœ… Teste Form Vazio: Passou"); passed++; }
                else console.error("âŒ Teste Form Vazio: Falhou");

                notify(`Testes finalizados: ${passed}/${total} passaram.`, passed === total ? 'success' : 'warning');
                console.groupEnd();
            };

            const filteredPatients = computed(() => {
                if (!searchQuery.value) return patients.value;
                const q = searchQuery.value.toLowerCase();
                return patients.value.filter(p => p.name.toLowerCase().includes(q) || p.cpf.includes(q));
            });

            const todayAppointments = computed(() => {
                const today = new Date().toISOString().split('T')[0];
                return appointments.value.filter(a => a.date === today && a.status !== 'cancelado');
            });

            const pageTitle = computed(() => {
                const item = menuItems.find(i => i.id === currentView.value);
                return item ? item.label : 'OdontoSys';
            });

            const getUserInitials = () => userData.value?.name ? userData.value.name.substring(0,2).toUpperCase() : 'U';
            const getPatientName = (id) => patients.value.find(p => p.id === id)?.name || 'Desconhecido';
            const getStatusClass = (s) => s === 'agendado' ? 'bg-blue-100 text-blue-700' : s === 'cancelado' ? 'bg-red-100 text-red-700' : 'bg-green-100 text-green-700';
            const getStatusColor = (s) => s === 'agendado' ? 'bg-blue-100 border-blue-500 text-blue-700' : s === 'confirmado' ? 'bg-green-100 border-green-500 text-green-700' : 'bg-gray-100 border-gray-500';
            const formatTime = (dateStr) => new Date(dateStr).toLocaleTimeString([], {hour: '2-digit', minute:'2-digit'});
            const formatDateTime = (iso) => new Date(iso).toLocaleString('pt-BR');
            const getPatientRecords = (pid) => records.value.filter(r => r.patientId === pid).sort((a,b) => new Date(b.date) - new Date(a.date));
            const getPatientFiles = (pid) => files.value.filter(f => f.patientId === pid);
            const calculateMonthlyRevenue = () => {
                return records.value.reduce((acc, curr) => acc + (curr.cost || 0), 0).toFixed(2);
            };

            const closeModal = () => {
                showModal.value = null;
                Object.keys(patientForm).forEach(k => patientForm[k] = k==='id'?null:'');
                Object.keys(appointmentForm).forEach(k => k!=='hour'? appointmentForm[k]='':null);
            };

            const openModal = (name) => {
                showModal.value = name;
            };

            const changeDate = (days) => {
                const d = new Date(selectedDate.value);
                d.setDate(d.getDate() + days);
                selectedDate.value = d.toISOString().split('T')[0];
            };

            onMounted(() => {
                onAuthStateChanged(auth, async (user) => {
                    if (user) {
                        currentUser.value = user;
                        try {
                            const userDoc = await getDocs(query(collection(db, 'users'), where('email', '==', user.email)));
                            if (!userDoc.empty) {
                                userData.value = { uid: user.uid, ...userDoc.docs[0].data() };
                                syncData();
                            } else {
                                userData.value = { uid: user.uid, name: user.displayName, role: 'reception' };
                            }
                        } catch(e) { console.error(e); }
                    } else {
                        currentUser.value = null;
                    }
                    loading.value = false;
                });
            });

            return {
                loading, currentUser, userData, authMode, sidebarOpen, isDark, currentView, notifications,
                loginForm, registerForm, patientForm, recordForm, appointmentForm,
                patients, appointments, users, filteredPatients, todayAppointments,
                showModal, selectedPatient, selectedDate, workHours, menuItems,
                handleLogin, handleRegister, logout, handleResetPassword, toggleDarkMode,
                savePatientForm, editPatient, selectPatient, saveAppointmentForm, saveRecordForm,
                handleFileUpload, deleteFile, deleteUser,
                exportToCSV, printRecord, backupData, restoreData, runSelfTests,
                openModal, closeModal, checkPermission,
                getUserInitials, getPatientName, getStatusClass, getStatusColor, formatTime, formatDateTime,
                getPatientRecords, getPatientFiles, calculateMonthlyRevenue,
                changeDate, getAppointmentsForHour, pageTitle, searchQuery
            };
        }
    }).mount('#app');
</script>